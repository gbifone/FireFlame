"//=============================================================================\n"
"// WaveSim.hlsl by Frank Luna (C) 2011 All Rights Reserved.\n"
"//\n"
"// UpdateWavesCS(): Solves 2D wave equation using the compute shader.\n"
"//\n"
"// DisturbWavesCS(): Runs one thread to disturb a grid height and its\n"
"//     neighbors to generate a wave. \n"
"//=============================================================================\n"
"\n"
"// For updating the simulation.\n"
"cbuffer cbUpdateSettings\n"
"{\n"
"    float gWaveConstant0;\n"
"    float gWaveConstant1;\n"
"    float gWaveConstant2;\n"
"\n"
"    float gDisturbMag;\n"
"    int2 gDisturbIndex;\n"
"};\n"
"\n"
"RWTexture2D<float> gPrevSolInput : register(u0);\n"
"RWTexture2D<float> gCurrSolInput : register(u1);\n"
"RWTexture2D<float> gOutput       : register(u2);\n"
"\n"
"[numthreads(16, 16, 1)]\n"
"void UpdateWavesCS(int3 dispatchThreadID : SV_DispatchThreadID)\n"
"{\n"
"    // We do not need to do bounds checking because:\n"
"    //	 *out-of-bounds reads return 0, which works for us--it just means the boundary of \n"
"    //    our water simulation is clamped to 0 in local space.\n"
"    //   *out-of-bounds writes are a no-op.\n"
"    int x = dispatchThreadID.x;\n"
"    int y = dispatchThreadID.y;\n"
"\n"
"    gOutput[int2(x, y)] =\n"
"        gWaveConstant0 * gPrevSolInput[int2(x, y)].r +\n"
"        gWaveConstant1 * gCurrSolInput[int2(x, y)].r +\n"
"        gWaveConstant2 *\n"
"        (\n"
"            gCurrSolInput[int2(x, y + 1)].r +\n"
"            gCurrSolInput[int2(x, y - 1)].r +\n"
"            gCurrSolInput[int2(x + 1, y)].r +\n"
"            gCurrSolInput[int2(x - 1, y)].r\n"
"        );\n"
"}\n"
"\n"
"[numthreads(1, 1, 1)]\n"
"void DisturbWavesCS\n"
"(   \n"
"    int3 groupThreadID : SV_GroupThreadID,\n"
"    int3 dispatchThreadID : SV_DispatchThreadID\n"
")\n"
"{\n"
"    // We do not need to do bounds checking because:\n"
"    //	 *out-of-bounds reads return 0, which works for us--it just means the boundary of \n"
"    //    our water simulation is clamped to 0 in local space.\n"
"    //   *out-of-bounds writes are a no-op.\n"
"    int x = gDisturbIndex.x;\n"
"    int y = gDisturbIndex.y;\n"
"    float halfMag = 0.5f*gDisturbMag;\n"
"\n"
"    // Buffer is RW so operator += is well defined.\n"
"    gOutput[int2(x, y)] += gDisturbMag;\n"
"    gOutput[int2(x + 1, y)] += halfMag;\n"
"    gOutput[int2(x - 1, y)] += halfMag;\n"
"    gOutput[int2(x, y + 1)] += halfMag;\n"
"    gOutput[int2(x, y - 1)] += halfMag;\n"
"}\n"
